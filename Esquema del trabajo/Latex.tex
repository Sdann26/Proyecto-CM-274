%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[journal]{IEEEtran}
\hyphenation{op-tical net-works semi-conduc-tor}
\documentclass[letterpaper, 10 pt, conference]{ieeeconf} 
\IEEEoverridecommandlockouts                
\overrideIEEEmargins

\title{\LARGE \bf Aplicaci\'on de Estructuras de Datos Probabil\'isticos en
}

\author{Samuel Leiva$^{1}$, Junior Micha$^{2}$, Danilo Blas$^{3}$, Joel Janampa$^{4}$, Brener Bustillos$^{5}$% <-this % stops a space
\thanks{Manuscrito creado el 21 de septiembre del 2018; cuya revisi\'on final sera el 9 de Noviembre del 2018. Este trabajo es compatible en formato IEEE y se distribuye bajo el Proyecto LaTeX.El manuscrito puede ser encontrado en los github de los autores}% <-this % stops a space
\thanks{$^{1}$ S. Leiva es estudiante de pregrado de ciencias de la computaci\'on, Universidad Nacional de Ingenier\'ia, 2015-2021, Lima, Peru\'.
        {\tt\small https://github.com/SamuelLeiva}}%
\thanks{$^{2}$ J. Micha es estudiante de pregrado de matem\'atica, Universidad Nacional de Ingenier\'ia, 2016-2022, Lima, Per\'u.
        {\tt\small https://github.com/JMicha23}}%
\thanks{$^{3}$ D. Blas es estudiante de pregrado ciencias de la computaci\'on ,Universidad Nacional de Ingenier\'ia, 2015-2021, Lima,Per\'u.
        {\tt\small https://github.com/Sdann26}}%
\thanks{$^{4}$ J. Janampa es estudiante de pregrado de matem\'atica, Universidad Nacional de Ingenier\'ia, 2015-2021, Lima, Per\'u.
        {\tt\small https://github.com/JoelJanampaBautista}}%
\thanks{$^{5}$ B. Bustillos es estudiante de pregrado de matem\'atica, Universidad Nacional de Ingenier\'ia, 2015-2021, Lima, Per\'u. 
        {\tt\small https://github.com/brenner-08}}%
}


\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
    

Este articulo matem\'atico-computacional presenta los resultados obtenidos mediante un proceso de investigaci\'on sobre algunas estructuras de datos alternativas que pueden hacer que el trabajo de an\'alisis de datos sea un m\'as eficaz, antes de usar t\'ecnicas como un cl\'uster de co\'mputo para ejecutar herramientas distribuidas de co\'mputo paralelo como por ejemplo  Hadoop y Spark que son herramientas correctas, pero muy costosas.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCCI\'ON}

Este arti\'culo describe tres estructura de datos probabilísticas: Bloom Fitler, Count-min sketch e HyperLogLog, programaremos cada uno en lenguaje R y/o Python y comprobaremos su funcionamiento para el conteo y las consultas referidas a elementos dentro de un conjunto.

\subsection{Objetivos}
\begin{itemize}
    \item Aplicar la estructura bloom Fitler para hacer consultas sobre elementos que puedan pertenecer al conjunto analizado. 
    \item Usar la estructura Count-min sketch.
    \item Calcular el número aproximado de elementos en un multiconjunto usando la estructura HyperLogLog. 
\end{itemize}

En esta oportunidad usaremos cada una de las tres estructuras aplicadas sobre un problema real. En el primer (Bloom Filter) generaremos un conjuntos de n elementos aleatorios, seguidamente utilizaremos las funciones añadir y query(consultar) para añadir elementos y consultar si algún elemento pertenece al conjunto que hemos generado en el caso de la estructura Count-min sketch, finalmente con la estructura HyperLogLog generaremos un multiconjunto grande el cual calcularemos al cardinalidad de un elemento específico con una excatitud del 2\% usando 1,5kb de memoria.

\subsection{BLOOM FITLER}
\begin{itemize}
    \item Estructura de datos espacio eficiente (Borton Howard Bloom -1970).
    \item Usado para probar si un elemento es miembro de un conjunto.
    \item Una consulta arroja ``posiblemente en el conjunto" (falso positivo)  o ``definitivamente no en el conjunto" (falso negativo).
    \item Se puede agregar elementos al conjunto pero no removerlos.
    \item Mayores elementos con añadidos , mayores probabilidad de falsos positivos .
    \item Generalmente , menos de 10 bits por elemento son requeridos para un 1\% de probabilidad falso positivo , independientemente del tamaño o número de elementos del set .
    \begin{enumerate}
    \item {\bf Descripción de un algoritmo}: Arreglo de m bits , todo en 0 . También debe haber k funciones hash , cada uno de los cuales mapea algún elemento a una de las m posiciones (distribución aleatoria uniforme). 
    \item {\bf Para añadir un elemento}: Se alimenta a cada una de las k funciones para obtener k posiciones en el arreglo . Todas esas posiciones se van a 1 .
    \item {\bf Para consultar(si es que el elemento está)}: Se alimenta a cada una de las k funciones para obtener k posiciones en el arreglo , si algunas de las posiciones son 0 el elemento definitivamente no se encuentra en el conjunto , si todos son 1, entonces o bien el elemento está o los bits han sidos puestos a 1 cuando fueron insertados.
\end{enumerate}
\subsection{COUNT-MIN SKETCH}
\begin{itemize}
    \item Sirve como una tabla de frecuencia de eventos en una data stream . Usa funciones hash para mapear eventos a frecuencias , pero solo usa espacios sub-lineales a costa de "sobrecontar algunos eventos a causa de colisiones (2003-Graham Cormode , S.Muthu Muthokrishnan).
    \item Esencialmente es lo mismo que Bloom fitler, pero son usados de manera diferente y se ponen el tamaño de manera diferente.
\end{itemize}
\begin{enumerate}
    \item {\bf Estructura}: El objetivo de count-min sketch es la de consumir un stream de eventos , uno a la vez , y contar la frecuencia de los diferentes tipos de eventos en el stream . En cualquier momento el sketch puede ser consultado para la frecuencia de un particular tipo de evento y regresará un estimado de esta frecuencia dentro de una cierta distancia de la frecuencia real , con una cierta probabilidad.
\end{enumerate}
\subsection{HYPERLOGLOG}
\begin{itemize}
    \item Algoritmo para el conteo distintivo , aproximando el número de distintos elementos en un multiconjunto . Es capaz de estimar cardinalidades mayor a $10^9$ con una certeza del 2\% usando 1,5 kb de memoria.
\end{itemize}
\begin{enumerate}
    \item {\bf Algoritmo}: Se basa en la observación de que las cardinalidades de un multiconjunto de números aleatorios uniformemente distribuidos pueden ser calculados estimando el máximo número de ceros en la representación binaria de cada número en el conjunto . Si el máximo número de ceros observados es $n$ , un estimado para el número de elementos en el conjunto es $2^n$ .
    \item {\bf Operaciones} \\
    Add: Añade un elenento al conjunto.\\
    Count: Nos arroja la cardinalidad el conjunto.\\
     Merge: Para obtener la unión de dos conjuntos.
\end{enumerate}
\end{itemize}

\section{ESTADO DEL ARTE}

\begin{itemize}

\item \textbf{"Theory and Practice of Bloom Filters for Distributed Systems"}

Este articulo presenta una serie de técnicas probabilísticas como los Bloom-filters y sus variantes como stable Bloom Filter, Adaptative Bloom Filters, Filter Banks, etc. que se utilizan para reducir el procedimiento de la información y los costos de información.\\

\item \textbf{"An Improved Data Stream Summary: The Count-Min Sketch and its Applications"}

Este articulo presenta otras aplicaciones de la estructura de datos Count-min Sketch para problemas como encontrar cuartiles, elementos frecuentes, etc.\\

\item \textbf{"HyperLogLog in Practice: Algorithmic Engineering of a State of The Art Cardinality Estimation Algorithm"}

En este articulo se presentan mejoras al algoritmo HyperLogLog reduciendo sus requisitos de memoria y aumentar su precisión para un rango importante de cardinalidades.\\

\end{itemize}


\section{DISEÑO DEL EXPERIMENTO}


\subsection{JSJSJS}

\subsection{UnDSDFs}

\begin{itemize}

\item URWER 
\item AERWE
\item DFSDF
\item DDD, 

\end{itemize}


\subsection{Ecuaciones}

sdajflas ecuanciones

$$
\alpha + \beta = \chi \eqno{(1)}
$$

Note that the equation is centered using a 

\subsection{subitituo}
\begin{itemize}


\item 
\item 
\item  

\end{itemize}


\section{INTRODUCCION}

RELLENAR 

\subsection{PIRMER}



\subsection{LLENAR SI SE DESEA}



   \begin{figure}[thpb]
      \centering
      \framebox{\parbox{3in}{wiiiiisdshdfksbsdka
}}
      %\includegraphics[scale=1.0]{figurefile}
      \caption{descripcion de la imagen }
      \label{figurelabel}
   \end{figure}
   


\section{CONCLUSIONS}



\addtolength{\textheight}{-12cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{APPENDIX}

rellenear

\section*{ACKNOWLEDGMENT}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}

\bibitem{c1}
\bibitem{c2} 
\bibitem{c3} 


\end{thebibliography}

\end{document}
